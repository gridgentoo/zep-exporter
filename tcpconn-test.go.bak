package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/rand"
	"net"
	"sync"
	"syscall"
	"time"

	"github.com/gogo/protobuf/proto"
	"github.com/tinytub/zep-cli/proto/ZPMeta"
	"github.com/tinytub/zep-cli/proto/client"
)

type Connection struct {
	Conn       net.Conn
	Addr       string
	Data       chan []byte
	ok         int
	HasRequest chan bool
	RecvDone   chan bool
	mu         sync.Mutex
}

var (
	NodeConn map[string][]*Connection
	MetaConn map[string][]*Connection
	addrs    []string
)

func InitConns() {
	addrs = []string{"bada9305.add.bjyt.qihoo.net:9221"}
	MetaConn = make(map[string][]*Connection)

	for _, addr := range addrs {
		c := &Connection{}
		err := c.newConn(addr)
		if err != nil {
			fmt.Println("bad conn, continue")
			continue
		}
		fmt.Println(c.Conn)
		MetaConn[addr] = append(MetaConn[addr], c)
		go c.Recv()
	}
}

func (c *Connection) newConn(addr string) error {
	conn, err := net.DialTimeout("tcp", addr, 1000*time.Millisecond)
	if err != nil {
		fmt.Println("tcp conn err:", err)
		return err
	}

	c.Data = make(chan []byte, 4)
	c.RecvDone = make(chan bool)
	c.HasRequest = make(chan bool)
	c.Conn = conn
	c.Addr = addr
	return nil
}

func (c *Connection) Send(data []byte) error {

	buff := make([]byte, 4+len(data))
	binary.BigEndian.PutUint32(buff[0:4], uint32(len(data)))

	copy(buff[4:], data)

	_, err := c.Conn.Write(buff)

	if err != nil {
		fmt.Println("write err:", err)
		return err
	}

	fmt.Println("tcp write done")
	c.HasRequest <- true
	return nil
}

func (c *Connection) Recv() {
	i := 1
	for {
		//logger.Info("recv", i)
		select {
		case <-c.HasRequest:
			buf := make([]byte, 4)
			var size int32
			var data []byte
			reader := bufio.NewReader(c.Conn)
			//logger.Info(c.Conn, i)
			// 前四个字节一般表示网络包大小
			if count, err := io.ReadFull(reader, buf); err == nil && count == 4 {

				//logger.Info("reading", i)
				sbuf := bytes.NewBuffer(buf)
				// 先读数据长度
				binary.Read(sbuf, binary.BigEndian, &size)

				// 固定解析出的数据的存储空间
				data = make([]byte, size)

				// 整段读取
				count, err := io.ReadFull(reader, data)

				if err != nil {
					if err == syscall.EPIPE {
						fmt.Println("io read err:", err)
						//c.Conn.Close()
					}
					//			return
				}
				// 确认数据长度和从tcp 协议中获取的长度是否相同
				if count != int(size) {
					fmt.Println("wrong count")
				}
				c.Data <- data
			}
		case <-c.RecvDone:
			//c.Conn.Close()
			//		return
		case <-time.After(2000 * time.Millisecond):
			//c.Conn.Close()
			//		return
			// 这里还应该在 case 一个 停止的 sigal, 或者看要不要设置超时.

		}
		i = i + 1
	}
}

func (c *Connection) ProtoUnserialize(data []byte, tag string) interface{} {
	if tag == "meta" {
		newdata := &ZPMeta.MetaCmdResponse{}
		// protobuf 解析
		err := proto.Unmarshal(data, newdata)
		if err != nil {
			fmt.Println("unmarshaling error: ", err, c.Addr)
		}
		//    logger.Info(newdata)
		return newdata
	} else if tag == "node" {
		newdata := &client.CmdResponse{}
		// protobuf 解析
		err := proto.Unmarshal(data, newdata)
		if err != nil {
			fmt.Println("unmarshaling error: ", err, c.Addr)
		}
		//logger.Info(newdata)
		return newdata
	}
	return nil
}

func GetMetaConn() *Connection {
	addr := addrs[rand.Intn(len(addrs))]
	conn := MetaConn[addr][rand.Intn(len(MetaConn[addr]))]
	return conn
}

func ListNode() ([]*ZPMeta.NodeStatus, error) {
	conn := GetMetaConn()
	//conn.mu.Lock()
	data, _ := conn.ListNode()
	conn.RecvDone <- true
	if data.Code.String() != "OK" {
		return nil, errors.New(*data.Msg)
	}
	nodes := data.ListNode.Nodes.Nodes

	return nodes, nil
}

func (c *Connection) ListNode() (*ZPMeta.MetaCmdResponse, error) {
	cmd, err := c.MakeCmdListNode()
	if err != nil {
		fmt.Println("marshal proto error", err)
	}
	c.mu.Lock()
	c.Send(cmd)

	data, err := c.getData("meta")
	if data.(*ZPMeta.MetaCmdResponse).GetCode() != 0 {
		//cmdError.WithLabelValues("ListNode", string(data.(*ZPMeta.MetaCmdResponse).GetCode())).Inc()
		err = errors.New(data.(*ZPMeta.MetaCmdResponse).GetMsg())
	}
	if err != nil {
		//cmdError.WithLabelValues("ListNode", "999").Inc()
		return data.(*ZPMeta.MetaCmdResponse), err
	}

	c.mu.Unlock()

	return data.(*ZPMeta.MetaCmdResponse), nil
}

func (c *Connection) MakeCmdListNode() ([]byte, error) {

	raw_cmd := &ZPMeta.MetaCmd{
		Type: ZPMeta.Type_LISTNODE.Enum(),
	}

	return proto.Marshal(raw_cmd)
}

func ListMeta() (*ZPMeta.MetaNodes, error) {
	conn := GetMetaConn()

	//conn.mu.Lock()
	data, _ := conn.ListMeta()
	if data.Code.String() != "OK" {
		return &ZPMeta.MetaNodes{}, errors.New(*data.Msg)
	}
	metas := data.ListMeta.Nodes

	conn.RecvDone <- true
	return metas, nil
}

func (c *Connection) ListMeta() (*ZPMeta.MetaCmdResponse, error) {
	cmd, err := c.MakeCmdListMeta()
	if err != nil {
		fmt.Println("marshal proto error", err)
	}
	//logger.Info("listmeta")
	c.mu.Lock()

	c.Send(cmd)
	data, err := c.getData("meta")
	if data.(*ZPMeta.MetaCmdResponse).GetCode() != 0 {
		//cmdError.WithLabelValues("ListMeta", string(data.(*ZPMeta.MetaCmdResponse).GetCode())).Inc()
		err = errors.New(data.(*ZPMeta.MetaCmdResponse).GetMsg())
	}
	if err != nil {
		//cmdError.WithLabelValues("ListMeta", "999").Inc()
		return data.(*ZPMeta.MetaCmdResponse), err
	}

	c.mu.Unlock()

	return data.(*ZPMeta.MetaCmdResponse), nil
}

func (c *Connection) MakeCmdListMeta() ([]byte, error) {

	raw_cmd := &ZPMeta.MetaCmd{
		Type: ZPMeta.Type_LISTMETA.Enum(),
	}

	return proto.Marshal(raw_cmd)
}

func (c *Connection) getData(tag string) (interface{}, error) {
	//TODO 这里可以加 retry
	timeout := time.After(1 * time.Second)
	//    tick := time.Tick(500 * time.Millisecond)

	for {
		select {
		case rawdata := <-c.Data:
			if rawdata != nil {
				newdata := c.ProtoUnserialize(rawdata, tag)
				//close(c.RecvDone)
				return newdata, nil
			}
		case <-timeout:
			fmt.Println("time out 1 second")
			nildata := c.ProtoUnserialize(nil, tag)
			c.Conn.Close()
			return nildata, errors.New("time out in 1 second")
			/*
			   case <-time.After(5000 * time.Millisecond):
			       logger.Info("time out 5000ms")
			       //        return &ZPMeta.MetaCmdResponse{}
			       //return nil
			       continue
			*/
		}
	}
}

func main() {
	InitConns()
	wg := &sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(ListNode())
			wg.Done()
		}(wg, i)
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(ListMeta())
			wg.Done()
		}(wg, i)
	}

	time.Sleep(10 * time.Second)

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(ListNode())
			wg.Done()
		}(wg, i)
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(ListMeta())
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
}
